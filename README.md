# CS300-Portfolio
Overview

This repository contains selected artifacts from my CS 300: Data Structures and Algorithms coursework. The materials included here demonstrate my ability to analyze algorithm efficiency, evaluate data structures, and develop working software solutions using appropriate data structures and algorithms. These projects reflect both my technical growth and my ability to apply structured problem-solving techniques to real-world scenarios.

Included Artifacts
Project One: Data Structure Analysis

File: CS 300 Project One Submission.docx

Description:
This document contains a detailed analysis of runtime and memory usage for three data structures: vector, hash table, and binary search tree. It includes Big-O analysis, advantages and disadvantages of each structure, and a final recommendation based on performance and project requirements.

Project Two: Advising Assistance Program

File: ProjectTwo.cpp

Description:
A fully functional C++ command-line application that loads course data, stores it in a binary search tree, prints an alphanumerically sorted list of courses, and allows advisors to retrieve detailed course information including prerequisites.

Reflection
What problem was I solving in the projects for this course?

The primary problem was designing and implementing an advising assistance system for ABC University that could efficiently manage and retrieve course information. The system needed to support loading data from a file, sorting courses alphanumerically, and displaying course details along with prerequisites.

How did I approach the problem, and why are data structures important?

I approached the problem by first developing pseudocode and algorithm designs before writing code. I analyzed multiple data structures—vectors, hash tables, and binary search trees—to understand their performance trade-offs. Data structures are important because they directly impact runtime efficiency, memory usage, and scalability, especially when working with large datasets.

How did I overcome roadblocks encountered during the course?

Some challenges included managing file input correctly, debugging logic errors, and handling dynamic memory safely. I overcame these challenges by breaking problems into smaller steps, testing frequently, and revisiting my pseudocode when implementation issues occurred.

How has this project expanded my approach to software design?

This project reinforced the importance of planning before coding. Writing pseudocode, performing runtime analysis, and selecting the correct data structure upfront led to cleaner, more efficient implementations. I now approach software design with a stronger focus on performance, maintainability, and scalability.

How has this work influenced how I write maintainable and adaptable programs?

My work in CS 300 improved how I write readable and maintainable code by emphasizing modular design, clear naming conventions, and meaningful inline comments. These practices make my programs easier to understand, modify, and extend over time.

Conclusion

The artifacts in this repository demonstrate my ability to analyze complex problems, select appropriate data structures, and implement efficient algorithms. These skills form a strong foundation for future coursework and professional software development.
